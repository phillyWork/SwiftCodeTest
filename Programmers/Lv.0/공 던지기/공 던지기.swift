import Foundation

// element: 1 ~ 5
// k번째: 2번째 --> (2-1)*2 = 2 --> 1, 3 --> numbers[2] = 3
// k번째: 7번째 --> (7-1)*2 = 12 --> 1, 3, 5, 2, 4, 1, 3 --> 12 % 5 = 2 --> numbers[2] = 3
// k번째: 8번째 --> (8-1)*2 = 14 --> 1, 3, 5, 2, 4, 1, 3, 5 --> 14 % 5 = 4 --> numbers[4] = 5
// k번째: 9번째 --> (9-1)*2 = 16 --> 1, 3, 5, 2, 4, 1, 3, 5, 2 --> 16 % 5 = 1 --> numbers[1] = 2

// element: 1 ~ 8
// k번째: 2번째 --> (2-1)*2 = 2 --> 1, 3 --> numbers[2] = 3
// k번째: 7번째 --> (7-1)*2 = 12 --> 1, 3, 5, 7, 1, 3, 5 --> 12 % 8 = 4 --> numbers[4] = 5
// k번째: 8번째 --> (8-1)*2 = 14 --> 1, 3, 5, 7, 1, 3, 5, 7 --> 14 % 8 = 6 --> numbers[6] = 7
// k번째: 9번째 --> (9-1)*2 = 16 --> 1, 3, 5, 7, 1, 3, 5, 7, 1 --> 16 % 8 = 0 --> numbers[0] = 1


// 결국 첫번째 element에서 얼만큼 이동했는지 확인한 뒤, 해당 index의 element를 반환하면 된다.
// 첫번째는 1로 고정이므로 1을 뺀 k값에 2를 보폭으로 이동하는 것이기에 2를 곱한 것 만큼 이동한다고 보면 된다.
// 다만 원래 배열의 element 개수가 이동한 정도보다 적을 수 있으므로 나머지 계산으로 반복 이동을 한다고 생각한다.


// 중요: 홀수 번째만 이동하는 것이 아님
// 원형으로 구성, 이동하므로 배열의 element가 홀수 개이면 짝수번째 element로도 이동할 수 있음을 고려해야 한다.
 
func solution(_ numbers:[Int], _ k:Int) -> Int {
    return numbers[((k-1)*2) % numbers.count]
    
    // 1부터 순차적으로 증가하는 배열 제한사항을 고려한다면 다음과 같이 작성해도 무방
    // return (k - 1) * 2 % numbers.count + 1
}

